# Android开发课堂笔记：Activity与Fragment


## 第一部分：Activity

### 1. Activity的基本概念与创建

Activity是Android应用程序的四大组件之一，它提供了一个用户界面，用于与用户进行交互。一个Activity通常代表应用中的一个屏幕。当用户在应用中导航时，不同的Activity会在屏幕上显示。

#### 1.1 手动创建Activity与项目文件结构

在Android项目中手动创建一个Activity，通常涉及以下几个步骤：

1.  **创建Java/Kotlin类**：在项目的`java`目录下（或`kotlin`目录下），右键点击包名，选择`New` -> `Activity` -> `Empty Activity`（或选择其他模板）。这将自动生成一个新的Activity类文件。
2.  **配置AndroidManifest.xml**：Android系统通过`AndroidManifest.xml`文件来了解应用的所有组件。新创建的Activity会自动在`AndroidManifest.xml`中注册。例如：

    ```xml
    <activity android:name=".MyNewActivity">
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
    </activity>
    ```
    其中，`android.intent.action.MAIN`表示这是应用的入口Activity，`android.intent.category.LAUNCHER`表示它会出现在应用的启动器中。
3.  **创建布局文件**：通常，每个Activity都会关联一个布局文件（XML文件），用于定义其用户界面。这个文件通常位于`res/layout`目录下，命名方式通常为`activity_my_new.xml`。在Activity的`onCreate`方法中，通过`setContentView(R.layout.activity_my_new)`来加载布局。

**项目文件新增文件查看**：

当您创建一个新的Activity时，通常会在以下位置新增文件：

*   `app/src/main/java/your.package.name/MyNewActivity.java` (或 `.kt`)
*   `app/src/main/res/layout/activity_my_new.xml`
*   `app/src/main/AndroidManifest.xml` (会被修改，添加新的`<activity>`标签)

### 1.2 Activity生命周期与日志打印

Activity的生命周期是指Activity从创建到销毁的整个过程。Android系统通过一系列回调方法来管理Activity的生命周期。理解这些回调方法对于开发稳定、高效的Android应用至关重要。

主要的生命周期回调方法包括：

*   `onCreate()`: Activity首次创建时调用，通常在此处进行初始化操作，如设置布局、绑定数据等。
*   `onStart()`: Activity可见时调用，但可能还未与用户交互。
*   `onResume()`: Activity可见并可与用户交互时调用，Activity处于运行状态。
*   `onPause()`: Activity失去焦点或部分被遮挡时调用，通常在此处保存临时数据或停止耗时操作。
*   `onStop()`: Activity完全不可见时调用，通常在此处释放资源。
*   `onDestroy()`: Activity被销毁前调用，通常在此处进行最终的资源释放。
*   `onRestart()`: Activity从停止状态重新启动时调用。



### 1.3 Activity启动模式与任务栈

Activity的启动模式决定了Activity实例在任务栈中的管理方式。任务栈（Task Stack）是一个后进先出（LIFO）的栈结构，用于管理用户启动的Activity。每个应用都有自己的任务栈，但Activity也可以被放置在其他应用的栈中。

Android提供了四种启动模式：

*   **standard (标准模式)**：默认模式。每次启动Activity都会创建一个新的实例，并将其放入启动它的任务栈顶部。一个任务栈中可以有多个相同Activity的实例。
*   **singleTop (栈顶复用模式)**：如果目标Activity的实例已经位于当前任务栈的栈顶，则不再创建新的实例，而是直接复用栈顶的实例，并调用其`onNewIntent()`方法。如果不在栈顶，则创建新的实例。
*   **singleTask (栈内单例模式)**：如果目标Activity的实例已经存在于任何任务栈中，系统会将其上方的所有Activity出栈，使目标Activity成为栈顶，并调用其`onNewIntent()`方法。如果不存在，则创建一个新的实例并放入新的任务栈（或指定任务栈）中。
*   **singleInstance (全局单例模式)**：与`singleTask`类似，但更严格。具有`singleInstance`模式的Activity会单独存在于一个全新的任务栈中，并且该任务栈中只会有这一个Activity实例。其他Activity不能进入这个任务栈。

**设置启动模式**：

启动模式可以在`AndroidManifest.xml`中通过`android:launchMode`属性进行设置：

```xml
<activity
    android:name=".MyActivity"
    android:launchMode="singleTask">
</activity>
```

**通过adb命令查看任务栈信息**：

可以使用`adb shell dumpsys activity activities`命令来查看当前设备上所有Activity的任务栈信息。这个命令会输出大量信息，可以通过`grep`等工具进行过滤。

例如，查看当前顶层Activity的信息：

```bash
adb shell dumpsys activity activities | grep "Run #"
```

或者查看特定包名的任务栈信息：

```bash
adb shell dumpsys activity activities | grep "TaskRecord" -A 5
```

### 1.4 Intent的概念与使用

Intent是Android中用于在不同组件之间传递消息的对象。它主要用于启动Activity、启动Service、发送广播以及启动ContentProvider。Intent可以分为显式Intent和隐式Intent。

*   **显式Intent**：明确指定要启动的组件的名称（通常是类名）。适用于在同一个应用内部启动组件。

    ```java
    Intent intent = new Intent(this, TargetActivity.class);
    startActivity(intent);
    ```

*   **隐式Intent**：不明确指定要启动的组件，而是通过指定Action、Category、Data等信息，让系统根据这些信息找到合适的组件来启动。适用于启动系统内置应用或不同应用间的组件。

    ```java
    // 启动拨号盘的隐式Intent示例
    Intent dialIntent = new Intent(Intent.ACTION_DIAL);
    dialIntent.setData(Uri.parse("tel:10086")); // 设置要拨打的电话号码
    startActivity(dialIntent);
    ```

**Intent的重要组成部分**：

*   **Action (动作)**：表示要执行的操作，如`ACTION_VIEW`（查看）、`ACTION_DIAL`（拨号）、`ACTION_SEND`（发送）等。
*   **Category (类别)**：用于指定Action的额外信息，如`CATEGORY_LAUNCHER`（启动器应用）、`CATEGORY_BROWSABLE`（可被浏览器打开）等。
*   **Data (数据)**：URI（统一资源标识符），表示要操作的数据，如`tel:10086`、`http://www.google.com`等。
*   **Type (数据类型)**：指定Data的MIME类型，如`image/jpeg`、`text/plain`等。
*   **Component (组件)**：要启动的组件的名称（类名），仅用于显式Intent。
*   **Extras (附加信息)**：Bundle对象，用于传递额外的数据。
*   **Flags (标志位)**：用于控制Activity的启动方式，如`FLAG_ACTIVITY_NEW_TASK`、`FLAG_ACTIVITY_CLEAR_TOP`等。

## 第二部分：Fragment

### 2.1 Fragment的基本概念与创建显示

Fragment是Android 3.0（API Level 11）引入的，它代表Activity中的一部分用户界面或行为。一个Activity可以包含多个Fragment，也可以在多个Activity中复用同一个Fragment。Fragment的引入主要是为了解决平板电脑等大屏幕设备上的UI适配问题，以及实现更灵活的UI设计。

#### 2.1.1 创建并显示Fragment的两种方式：静态添加和事务添加

**1. 静态添加 (Static Addition)**：

静态添加Fragment是指在Activity的布局文件中直接声明Fragment。这种方式简单直接，但灵活性较低，Fragment的生命周期与Activity紧密绑定。

**步骤**：

1.  **创建Fragment类**：继承`androidx.fragment.app.Fragment`（或`android.app.Fragment`，取决于API版本），并重写`onCreateView()`方法来加载Fragment的布局。

2.  **创建Fragment布局文件**：在`res/layout`目录下创建`fragment_static.xml`。

3.  **在Activity布局文件中声明Fragment**：

**优点**：实现简单。
**缺点**：不够灵活，无法在运行时动态替换或移除。

**2. 事务添加 (Transaction Addition)**：

事务添加Fragment是指在运行时通过`FragmentManager`和`FragmentTransaction`来动态地添加、移除、替换或隐藏Fragment。这种方式提供了更大的灵活性和控制力。

**步骤**：

1.  **创建Fragment类**：与静态添加类似，创建Fragment类和布局文件。

2.  **在Activity布局文件中添加一个容器**：通常是一个`FrameLayout`或`LinearLayout`，用于容纳动态添加的Fragment。

    ```xml
    <FrameLayout
        android:id="@+id/fragment_container"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
    ```

3.  **在Activity代码中进行事务操作**：


### 2.2 FragmentManager的使用与回退栈

`FragmentManager`是管理Activity中Fragment的核心类。它负责执行Fragment事务（添加、移除、替换等），并管理Fragment的回退栈。

**获取FragmentManager**：

*   在Activity中：`getSupportFragmentManager()` (使用`androidx.fragment.app.FragmentManager`) 或 `getFragmentManager()` (使用`android.app.FragmentManager`，已废弃)。
*   在Fragment中：`getParentFragmentManager()` (获取宿主Activity的FragmentManager) 或 `getChildFragmentManager()` (获取当前Fragment的子FragmentManager)。

**FragmentTransaction**：

`FragmentTransaction`是用于执行Fragment操作的API。每次操作（如`add()`、`remove()`、`replace()`）都需要通过`beginTransaction()`获取一个事务实例，然后执行操作，最后通过`commit()`或`commitAllowingStateLoss()`提交事务。

#### 2.2.1 `add`与`replace`的区别

*   **`add(int containerViewId, Fragment fragment, String tag)`**：
    *   将一个Fragment添加到指定的容器中。如果容器中已经有Fragment，新的Fragment会叠加在原有Fragment之上。原有Fragment不会被销毁，只是被新Fragment遮挡。
    *   适用于需要同时显示多个Fragment，或者需要保留原有Fragment状态的场景。

*   **`replace(int containerViewId, Fragment fragment, String tag)`**：
    *   先移除容器中所有现有的Fragment，然后添加新的Fragment。被移除的Fragment的`onDestroyView()`、`onDetach()`等生命周期方法会被调用（如果事务没有添加到回退栈）。
    *   适用于需要完全替换容器内容的场景，例如Tab切换。


#### 2.2.2 回退栈 (Back Stack) 的概念

回退栈是`FragmentManager`维护的一个栈结构，用于保存Fragment事务。当用户按下返回键时，系统会从回退栈中弹出最近的一个事务，并回滚该事务，从而恢复到上一个Fragment的状态。

**将事务添加到回退栈**：

在提交Fragment事务之前，调用`addToBackStack(String name)`方法可以将该事务添加到回退栈中。`name`参数是可选的，用于给事务命名，方便后续查找。

```java
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
fragmentTransaction.replace(R.id.fragment_container, new MyFragment());
fragmentTransaction.addToBackStack(null); // 将此事务添加到回退栈
fragmentTransaction.commit();
```

**回退栈操作**：

*   **`popBackStack()`**：弹出回退栈中最顶层的Fragment事务。
*   **`popBackStack(String name, int flags)`**：弹出指定名称或指定标志的Fragment事务。
*   **`getBackStackEntryCount()`**：获取回退栈中事务的数量。

### 2.3 Fragment生命周期与Activity的关联性

Fragment拥有自己的生命周期，但它的生命周期与宿主Activity的生命周期紧密关联。Fragment的生命周期回调方法与Activity的生命周期回调方法类似，但多了一些与Activity交互相关的回调。

**Fragment的主要生命周期回调方法**：

*   `onAttach(Context context)`: Fragment与Activity建立关联时调用。
*   `onCreate(Bundle savedInstanceState)`: Fragment被创建时调用，通常在此处进行非视图的初始化操作。
*   `onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)`: Fragment的UI被创建时调用，返回Fragment的根视图。
*   `onViewCreated(View view, Bundle savedInstanceState)`: `onCreateView()`返回后，视图被创建完成时调用。
*   `onActivityCreated(Bundle savedInstanceState)`: 宿主Activity的`onCreate()`方法执行完毕时调用。
*   `onStart()`: Fragment可见时调用。
*   `onResume()`: Fragment可见并可与用户交互时调用。
*   `onPause()`: Fragment失去焦点或部分被遮挡时调用。
*   `onStop()`: Fragment完全不可见时调用。
*   `onDestroyView()`: Fragment的UI被移除时调用。
*   `onDestroy()`: Fragment被销毁时调用。
*   `onDetach()`: Fragment与Activity解除关联时调用。

**通过日志打印熟悉生命周期执行顺序**：

与Activity类似，在Fragment的每个生命周期回调方法中添加日志输出，可以帮助我们观察其执行顺序，并理解其与宿主Activity生命周期的关联。

**Fragment与Activity生命周期的关联性**：

*   当Activity进入某个生命周期状态时，其内部的Fragment也会相应地进入其生命周期状态。
*   例如，当Activity的`onCreate()`被调用时，Fragment的`onAttach()`、`onCreate()`、`onCreateView()`、`onViewCreated()`、`onActivityCreated()`会依次被调用。
*   当Activity的`onPause()`被调用时，Fragment的`onPause()`也会被调用。
*   当Activity的`onDestroy()`被调用时，Fragment的`onDestroyView()`、`onDestroy()`、`onDetach()`会依次被调用。
*   Fragment的生命周期不能独立于其宿主Activity存在。如果Activity被销毁，其内部的所有Fragment也会被销毁。

## 第三部分：Fragment高级主题

### 3.1 Fragment之间的通信

在多Fragment的应用中，Fragment之间经常需要进行数据传递或事件通知。Fragment之间的通信方式主要有以下几种：

1.  **通过宿主Activity作为中介**：
    *   **Fragment向Activity通信**：Fragment定义接口，Activity实现该接口。Fragment通过`onAttach()`方法获取Activity的引用，然后调用接口方法向Activity传递数据或通知事件。
    *   **Activity向Fragment通信**：Activity可以直接调用Fragment的公共方法。或者，Activity可以通过`FragmentManager`找到Fragment实例，然后调用其方法。

2.  **通过ViewModel**：
    *   使用`ViewModel`是推荐的Fragment间通信方式，尤其是在需要共享数据和处理生命周期感知型数据时。多个Fragment可以共享同一个`ViewModel`实例，通过`LiveData`或`StateFlow`等观察者模式实现数据同步。

3.  **通过Bundle传递参数**：
    *   在创建Fragment实例时，可以通过`setArguments(Bundle bundle)`方法向Fragment传递初始化参数。Fragment在`onCreate()`方法中通过`getArguments()`获取这些参数。

4.  **通过Target Fragment**：
    *   当一个Fragment需要从另一个Fragment获取结果时，可以使用`setTargetFragment()`和`getTargetFragment()`。这种方式在Fragment嵌套较深时比较有用。

### 3.2 ViewPager与Fragment

`ViewPager`是一个布局管理器，允许用户在多个页面之间左右滑动。它通常与`Fragment`结合使用，每个页面对应一个Fragment，从而实现滑动切换的Tab布局或引导页。

**使用ViewPager与Fragment的步骤**：

1.  **添加ViewPager依赖**：在`build.gradle`文件中添加`ViewPager2`的依赖（`ViewPager`已废弃）。

    ```gradle
    implementation "androidx.viewpager2:viewpager2:1.0.0"
    ```

2.  **在布局文件中添加ViewPager2**：

    ```xml
    <androidx.viewpager2.widget.ViewPager2
        android:id="@+id/view_pager"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
    ```

3.  **创建FragmentStateAdapter**：继承`FragmentStateAdapter`，并重写`createFragment()`和`getItemCount
(Content truncated due to size limit. Use line ranges to read in chunks)
