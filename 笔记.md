
# Android 四大组件课堂笔记

---

## 一、Service 与 AIDL

### 1. Service 的使用与生命周期详解

- **定义**：Service 是一种在后台执行长时间运行操作而不需要用户界面的组件。
- **生命周期方法**：
  - `onCreate()`：首次创建时调用，通常进行初始化操作。
  - `onStartCommand()`：每次通过 `startService()` 启动服务时调用。
  - `onDestroy()`：服务被终止前调用，释放资源。
- **两种启动方式**：
  - 启动服务 `startService()`：执行完后需要手动 `stopService()` 或 `stopSelf()` 停止。
  - 绑定服务 `bindService()`：与客户端绑定，当客户端解绑时自动停止。
- **注意事项**：
  - 默认运行在主线程，需使用线程或异步处理耗时任务。
  - Android 8.0 后需使用前台服务（加通知栏）以避免服务被系统杀掉。

```java
public class MyService extends Service {
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        new Thread(() -> {
            // 执行耗时操作
        }).start();
        return START_STICKY;
    }
}
```

---

### 2. IntentService 的使用

- **特点**：
  - 基于 `HandlerThread`，自动开启子线程处理任务。
  - 每个 Intent 单独处理，按顺序执行。
  - 任务执行完后自动停止，无需手动调用 `stopSelf()`。
- **适用场景**：
  - 上传日志
  - 后台上传文件
  - 数据同步
- **注意事项**：
  - 已被官方废弃，推荐使用 `JobIntentService` 或 `WorkManager` 替代。

```java
public class MyIntentService extends IntentService {
    public MyIntentService() {
        super("MyIntentService");
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        // 处理后台任务
    }
}
```

---

### 3. AIDL 实现跨进程通信

- **场景**：当一个应用需要将服务提供给其他应用使用，如音乐播放服务、系统服务（ActivityManager）。
- **原理**：基于 Binder 机制实现 IPC 通信。
- **使用步骤**：
  1. 创建 `.aidl` 接口文件，定义需要跨进程调用的方法。
  2. 系统自动生成 `Stub` 抽象类。
  3. 服务端实现 `Stub` 并在 `onBind()` 返回。
  4. 客户端 `bindService()` 并调用方法。
- **注意事项**：
  - 服务端与客户端需保证 `.aidl` 文件完全一致。
  - Android 11 起要求 `<service android:exported="true" />`

```aidl
// IMyAidlInterface.aidl
interface IMyAidlInterface {
    int add(int a, int b);
}
```

---

## 二、广播接收器 BroadcastReceiver

### 1. 广播接收器的定义与作用

- **定义**：用于监听系统或应用发出的广播信息并做出响应。
- **常见用途**：
  - 监听网络变化、电池电量、开机启动等系统事件。
  - 模块解耦通信，例如：登录成功后广播通知刷新用户界面。
- **广播类型**：
  - 普通广播（异步）
  - 有序广播（同步，有优先级，可中断）
  - 粘性广播（已废弃）

---

### 2. 广播注册方式

#### 静态注册（清单文件）

```xml
<receiver android:name=".StaticReceiver" android:exported="true">
    <intent-filter>
        <action android:name="com.example.MY_BROADCAST"/>
    </intent-filter>
</receiver>
```

#### 动态注册（Java 代码中）

```java
BroadcastReceiver receiver = new MyReceiver();
IntentFilter filter = new IntentFilter("com.example.MY_BROADCAST");
registerReceiver(receiver, filter);
```

#### 发送广播

```java
Intent intent = new Intent("com.example.MY_BROADCAST");
sendBroadcast(intent); // 普通广播
sendOrderedBroadcast(intent, null); // 有序广播
```

#### 注意事项

- Android 8.0+ 限制静态注册隐式广播，推荐使用动态注册。
- 动态注册需要手动取消注册，避免内存泄漏：

```java
@Override
protected void onDestroy() {
    super.onDestroy();
    unregisterReceiver(receiver);
}
```

---

## 三、内容提供者 ContentProvider

### 1. ContentProvider 的作用与应用场景

- **作用**：统一对数据库、文件等数据的访问接口，实现应用间数据共享。
- **应用场景**：
  - 访问系统联系人、短信、媒体库
  - 自定义数据共享（如图书、日程等）

---

### 2. ContentProvider 与 Uri 结构

- **Uri 格式**：

```
content://<authority>/<path>/<id>
```

- **示例解释**：

```
content://com.android.contacts/contacts/1
```

  - `content://`：Uri 协议头
  - `com.android.contacts`：ContentProvider 的 authority
  - `contacts`：资源路径
  - `1`：资源 ID

---

### 3. ContentResolver 的使用与案例

#### 常用方法

- `query()`：查询数据
- `insert()`：插入数据
- `update()`：更新数据
- `delete()`：删除数据

#### 示例：查询联系人

```java
Cursor cursor = getContentResolver().query(
    ContactsContract.Contacts.CONTENT_URI,
    null, null, null, null);

while (cursor.moveToNext()) {
    String name = cursor.getString(
        cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME));
    Log.d("联系人", name);
}
```

#### 动态权限请求

```xml
<uses-permission android:name="android.permission.READ_CONTACTS"/>
```

```java
ActivityCompat.requestPermissions(
    this, new String[]{Manifest.permission.READ_CONTACTS}, 1);
```

---



